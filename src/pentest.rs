use anyhow::{Context, Result};
use colored::*;
use indicatif::{ProgressBar, ProgressStyle};
use std::fs;
use std::process::Command as ProcessCommand;
use walkdir::WalkDir;

// Cross-platform permissions support
#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;

#[cfg(unix)]
fn get_file_mode(metadata: &std::fs::Metadata) -> u32 {
    metadata.permissions().mode()
}

#[cfg(not(unix))]
#[allow(dead_code)]
fn get_file_mode(_metadata: &std::fs::Metadata) -> u32 {
    // On Windows, we can't get Unix-style permissions
    // Return 0 to indicate not available
    0
}

/// Find SUID binaries (setuid - run as owner)
pub fn find_suid_binaries(
    path: &str,
    quiet: bool,
    verbose: bool,
    output_file: Option<String>,
) -> Result<()> {
    #[cfg(not(unix))]
    {
        let _ = (path, quiet, verbose, output_file);
        eprintln!(
            "{}",
            "Warning: SUID detection is only available on Unix/Linux systems.".yellow()
        );
        eprintln!(
            "{}",
            "This feature requires Unix file permissions.".yellow()
        );
        Ok(())
    }

    #[cfg(unix)]
    {
        if !quiet {
            println!(
                "\n{} SUID binaries from: {}\n",
                "üîç Scanning for".bold(),
                path.cyan()
            );
        }

        let mut results = Vec::new();

        let walker = WalkDir::new(path)
            .follow_links(false)
            .into_iter()
            .filter_entry(|e| {
                // Skip certain directories that are typically not interesting
                if let Some(name) = e.file_name().to_str() {
                    !name.starts_with('.')
                } else {
                    true
                }
            });

        let pb = if !quiet {
            let pb = ProgressBar::new_spinner();
            pb.set_style(
                ProgressStyle::default_spinner()
                    .template("{spinner:.cyan} {msg}")
                    .unwrap(),
            );
            pb.set_message("Scanning...");
            Some(pb)
        } else {
            None
        };

        for entry in walker.filter_map(|e| e.ok()) {
            if let Some(ref pb) = pb {
                pb.tick();
            }

            if entry.file_type().is_file()
                && let Ok(metadata) = entry.metadata()
            {
                let mode = get_file_mode(&metadata);
                // Check for SUID bit (04000)
                if mode & 0o4000 != 0 {
                    let path_str = entry.path().display().to_string();
                    results.push((path_str.clone(), mode));

                    if verbose {
                        println!(
                            "{} {} (mode: {:o})",
                            "‚úì".green().bold(),
                            path_str.yellow(),
                            mode
                        );
                    } else if !quiet {
                        println!("{}", path_str.yellow());
                    } else {
                        println!("{}", path_str);
                    }
                }
            }
        }

        if let Some(pb) = pb {
            pb.finish_and_clear();
        }

        if !quiet {
            println!(
                "\n{} {} SUID binaries found",
                "‚úì".green().bold(),
                results.len().to_string().cyan().bold()
            );
        }

        // Write to output file if specified
        if let Some(output) = output_file {
            let content = results
                .iter()
                .map(|(p, m)| format!("{} (mode: {:o})", p, m))
                .collect::<Vec<_>>()
                .join("\n");
            fs::write(&output, content)
                .with_context(|| format!("Failed to write to output file: {}", output))?;
            if !quiet {
                println!("Results saved to: {}", output.cyan());
            }
        }

        Ok(())
    }
}

/// Find SGID binaries (setgid - run as group)
pub fn find_sgid_binaries(
    path: &str,
    quiet: bool,
    verbose: bool,
    output_file: Option<String>,
) -> Result<()> {
    #[cfg(not(unix))]
    {
        let _ = (path, quiet, verbose, output_file);
        eprintln!(
            "{}",
            "Warning: SGID detection is only available on Unix/Linux systems.".yellow()
        );
        eprintln!(
            "{}",
            "This feature requires Unix file permissions.".yellow()
        );
        Ok(())
    }

    #[cfg(unix)]
    {
        if !quiet {
            println!(
                "\n{} SGID binaries from: {}\n",
                "üîç Scanning for".bold(),
                path.cyan()
            );
        }

        let mut results = Vec::new();

        let walker = WalkDir::new(path)
            .follow_links(false)
            .into_iter()
            .filter_entry(|e| {
                if let Some(name) = e.file_name().to_str() {
                    !name.starts_with('.')
                } else {
                    true
                }
            });

        let pb = if !quiet {
            let pb = ProgressBar::new_spinner();
            pb.set_style(
                ProgressStyle::default_spinner()
                    .template("{spinner:.cyan} {msg}")
                    .unwrap(),
            );
            pb.set_message("Scanning...");
            Some(pb)
        } else {
            None
        };

        for entry in walker.filter_map(|e| e.ok()) {
            if let Some(ref pb) = pb {
                pb.tick();
            }

            if entry.file_type().is_file()
                && let Ok(metadata) = entry.metadata()
            {
                let mode = get_file_mode(&metadata);
                // Check for SGID bit (02000)
                if mode & 0o2000 != 0 {
                    let path_str = entry.path().display().to_string();
                    results.push((path_str.clone(), mode));

                    if verbose {
                        println!(
                            "{} {} (mode: {:o})",
                            "‚úì".green().bold(),
                            path_str.yellow(),
                            mode
                        );
                    } else if !quiet {
                        println!("{}", path_str.yellow());
                    } else {
                        println!("{}", path_str);
                    }
                }
            }
        }

        if let Some(pb) = pb {
            pb.finish_and_clear();
        }

        if !quiet {
            println!(
                "\n{} {} SGID binaries found",
                "‚úì".green().bold(),
                results.len().to_string().cyan().bold()
            );
        }

        if let Some(output) = output_file {
            let content = results
                .iter()
                .map(|(p, m)| format!("{} (mode: {:o})", p, m))
                .collect::<Vec<_>>()
                .join("\n");
            fs::write(&output, content)
                .with_context(|| format!("Failed to write to output file: {}", output))?;
            if !quiet {
                println!("Results saved to: {}", output.cyan());
            }
        }

        Ok(())
    }
}

/// Find world-writable files and directories
pub fn find_writable(
    path: &str,
    quiet: bool,
    verbose: bool,
    dirs_only: bool,
    files_only: bool,
    output_file: Option<String>,
) -> Result<()> {
    #[cfg(not(unix))]
    {
        let _ = (path, quiet, verbose, dirs_only, files_only, output_file);
        eprintln!(
            "{}",
            "Warning: World-writable detection is only available on Unix/Linux systems.".yellow()
        );
        eprintln!(
            "{}",
            "This feature requires Unix file permissions.".yellow()
        );
        Ok(())
    }

    #[cfg(unix)]
    {
        let target = if dirs_only {
            "directories"
        } else if files_only {
            "files"
        } else {
            "files and directories"
        };

        if !quiet {
            println!(
                "\n{} world-writable {} from: {}\n",
                "üîç Scanning for".bold(),
                target,
                path.cyan()
            );
        }

        let mut results = Vec::new();

        let walker = WalkDir::new(path)
            .follow_links(false)
            .into_iter()
            .filter_entry(|e| {
                if let Some(name) = e.file_name().to_str() {
                    !name.starts_with('.')
                } else {
                    true
                }
            });

        let pb = if !quiet {
            let pb = ProgressBar::new_spinner();
            pb.set_style(
                ProgressStyle::default_spinner()
                    .template("{spinner:.cyan} {msg}")
                    .unwrap(),
            );
            pb.set_message("Scanning...");
            Some(pb)
        } else {
            None
        };

        for entry in walker.filter_map(|e| e.ok()) {
            if let Some(ref pb) = pb {
                pb.tick();
            }

            let is_dir = entry.file_type().is_dir();
            let is_file = entry.file_type().is_file();

            // Apply filters
            if dirs_only && !is_dir {
                continue;
            }
            if files_only && !is_file {
                continue;
            }

            if (is_dir || is_file)
                && let Ok(metadata) = entry.metadata()
            {
                let mode = get_file_mode(&metadata);
                // Check for world-writable (o+w = 002)
                if mode & 0o002 != 0 {
                    let path_str = entry.path().display().to_string();
                    let type_str = if is_dir { "DIR" } else { "FILE" };
                    results.push((path_str.clone(), mode, type_str.to_string()));

                    if verbose {
                        println!(
                            "{} [{}] {} (mode: {:o})",
                            "‚úì".green().bold(),
                            type_str.blue(),
                            path_str.yellow(),
                            mode
                        );
                    } else if !quiet {
                        println!("[{}] {}", type_str.blue(), path_str.yellow());
                    } else {
                        println!("{}", path_str);
                    }
                }
            }
        }

        if let Some(pb) = pb {
            pb.finish_and_clear();
        }

        if !quiet {
            println!(
                "\n{} {} world-writable {} found",
                "‚úì".green().bold(),
                results.len().to_string().cyan().bold(),
                target
            );
        }

        if let Some(output) = output_file {
            let content = results
                .iter()
                .map(|(p, m, t)| format!("[{}] {} (mode: {:o})", t, p, m))
                .collect::<Vec<_>>()
                .join("\n");
            fs::write(&output, content)
                .with_context(|| format!("Failed to write to output file: {}", output))?;
            if !quiet {
                println!("Results saved to: {}", output.cyan());
            }
        }

        Ok(())
    }
}

/// Find files with capabilities
pub fn find_capabilities(
    path: &str,
    quiet: bool,
    verbose: bool,
    output_file: Option<String>,
) -> Result<()> {
    if !quiet {
        println!(
            "\n{} files with capabilities from: {}\n",
            "üîç Scanning for".bold(),
            path.cyan()
        );
    }

    let mut results = Vec::new();

    let walker = WalkDir::new(path)
        .follow_links(false)
        .into_iter()
        .filter_entry(|e| {
            if let Some(name) = e.file_name().to_str() {
                !name.starts_with('.')
            } else {
                true
            }
        });

    let pb = if !quiet {
        let pb = ProgressBar::new_spinner();
        pb.set_style(
            ProgressStyle::default_spinner()
                .template("{spinner:.cyan} {msg}")
                .unwrap(),
        );
        pb.set_message("Scanning...");
        Some(pb)
    } else {
        None
    };

    for entry in walker.filter_map(|e| e.ok()) {
        if let Some(ref pb) = pb {
            pb.tick();
        }

        if entry.file_type().is_file() {
            let path = entry.path();
            // Use getcap to check for capabilities
            if let Ok(output) = ProcessCommand::new("getcap").arg(path).output() {
                let stdout = String::from_utf8_lossy(&output.stdout);
                if !stdout.trim().is_empty() && stdout.contains("=") {
                    let path_str = path.display().to_string();
                    results.push((path_str.clone(), stdout.trim().to_string()));

                    if verbose {
                        println!("{} {}", "‚úì".green().bold(), stdout.trim().yellow());
                    } else if !quiet {
                        println!("{}", stdout.trim().yellow());
                    } else {
                        println!("{}", path_str);
                    }
                }
            }
        }
    }

    if let Some(pb) = pb {
        pb.finish_and_clear();
    }

    if !quiet {
        println!(
            "\n{} {} files with capabilities found",
            "‚úì".green().bold(),
            results.len().to_string().cyan().bold()
        );
    }

    if let Some(output) = output_file {
        let content = results
            .iter()
            .map(|(p, c)| format!("{}: {}", p, c))
            .collect::<Vec<_>>()
            .join("\n");
        fs::write(&output, content)
            .with_context(|| format!("Failed to write to output file: {}", output))?;
        if !quiet {
            println!("Results saved to: {}", output.cyan());
        }
    }

    Ok(())
}

/// Find interesting config files
pub fn find_configs(
    path: &str,
    quiet: bool,
    verbose: bool,
    output_file: Option<String>,
) -> Result<()> {
    if !quiet {
        println!(
            "\n{} interesting configuration files from: {}\n",
            "üîç Scanning for".bold(),
            path.cyan()
        );
    }

    let interesting_patterns = vec![
        "*.conf",
        "*.config",
        "*.cfg",
        "*.ini",
        "*.yaml",
        "*.yml",
        "*.json",
        "*.xml",
        "*passwd*",
        "*shadow*",
        "*.key",
        "*.pem",
        "*.crt",
        "*.csr",
        "*credential*",
        "*password*",
        "*.env",
        ".bashrc",
        ".bash_profile",
        ".zshrc",
        ".profile",
        "id_rsa",
        "id_dsa",
        "id_ecdsa",
        "id_ed25519",
        "authorized_keys",
        "known_hosts",
    ];

    let mut results = Vec::new();

    let walker = WalkDir::new(path)
        .follow_links(false)
        .into_iter()
        .filter_entry(|e| {
            if let Some(name) = e.file_name().to_str() {
                !name.starts_with('.')
                    || interesting_patterns.iter().any(|p| {
                        // Check if it's a hidden file we care about
                        p.starts_with('.') && name == p.trim_start_matches('*')
                    })
            } else {
                true
            }
        });

    let pb = if !quiet {
        let pb = ProgressBar::new_spinner();
        pb.set_style(
            ProgressStyle::default_spinner()
                .template("{spinner:.cyan} {msg}")
                .unwrap(),
        );
        pb.set_message("Scanning...");
        Some(pb)
    } else {
        None
    };

    for entry in walker.filter_map(|e| e.ok()) {
        if let Some(ref pb) = pb {
            pb.tick();
        }

        if entry.file_type().is_file() {
            let file_name = entry.file_name().to_string_lossy().to_lowercase();
            let path_str = entry.path().display().to_string().to_lowercase();

            let is_interesting = interesting_patterns.iter().any(|pattern| {
                let pattern = pattern.to_lowercase();
                if pattern.starts_with('*') && pattern.ends_with('*') {
                    let inner = pattern.trim_matches('*');
                    file_name.contains(inner) || path_str.contains(inner)
                } else if pattern.starts_with('*') {
                    let suffix = pattern.trim_start_matches('*');
                    file_name.ends_with(suffix)
                } else if pattern.ends_with('*') {
                    let prefix = pattern.trim_end_matches('*');
                    file_name.starts_with(prefix)
                } else {
                    file_name == pattern
                }
            });

            if is_interesting {
                let original_path = entry.path().display().to_string();
                let size = entry.metadata().ok().map(|m| m.len()).unwrap_or(0);
                results.push((original_path.clone(), size));

                if verbose {
                    println!(
                        "{} {} ({})",
                        "‚úì".green().bold(),
                        original_path.yellow(),
                        humansize::format_size(size, humansize::BINARY).cyan()
                    );
                } else if !quiet {
                    println!("{}", original_path.yellow());
                } else {
                    println!("{}", original_path);
                }
            }
        }
    }

    if let Some(pb) = pb {
        pb.finish_and_clear();
    }

    if !quiet {
        println!(
            "\n{} {} interesting config files found",
            "‚úì".green().bold(),
            results.len().to_string().cyan().bold()
        );
    }

    if let Some(output) = output_file {
        let content = results
            .iter()
            .map(|(p, s)| format!("{} ({})", p, humansize::format_size(*s, humansize::BINARY)))
            .collect::<Vec<_>>()
            .join("\n");
        fs::write(&output, content)
            .with_context(|| format!("Failed to write to output file: {}", output))?;
        if !quiet {
            println!("Results saved to: {}", output.cyan());
        }
    }

    Ok(())
}

/// Find files modified in the last N minutes (useful for detecting recent changes)
pub fn find_recently_modified(
    path: &str,
    minutes: u64,
    quiet: bool,
    verbose: bool,
    output_file: Option<String>,
) -> Result<()> {
    use std::time::{SystemTime, UNIX_EPOCH};

    if !quiet {
        println!(
            "\n{} files modified in the last {} minutes from: {}\n",
            "üîç Scanning for".bold(),
            minutes.to_string().cyan(),
            path.cyan()
        );
    }

    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    let threshold = now - (minutes * 60);

    let mut results = Vec::new();

    let walker = WalkDir::new(path).follow_links(false);

    let pb = if !quiet {
        let pb = ProgressBar::new_spinner();
        pb.set_style(
            ProgressStyle::default_spinner()
                .template("{spinner:.cyan} {msg}")
                .unwrap(),
        );
        pb.set_message("Scanning...");
        Some(pb)
    } else {
        None
    };

    for entry in walker.into_iter().filter_map(|e| e.ok()) {
        if let Some(ref pb) = pb {
            pb.tick();
        }

        if entry.file_type().is_file()
            && let Ok(metadata) = entry.metadata()
            && let Ok(modified) = metadata.modified()
        {
            let modified_secs = modified.duration_since(UNIX_EPOCH).unwrap().as_secs();
            if modified_secs >= threshold {
                let path_str = entry.path().display().to_string();
                results.push((path_str.clone(), modified_secs));

                if verbose {
                    let elapsed = now - modified_secs;
                    let mins_ago = elapsed / 60;
                    println!(
                        "{} {} ({} minutes ago)",
                        "‚úì".green().bold(),
                        path_str.yellow(),
                        mins_ago.to_string().cyan()
                    );
                } else if !quiet {
                    println!("{}", path_str.yellow());
                } else {
                    println!("{}", path_str);
                }
            }
        }
    }

    if let Some(pb) = pb {
        pb.finish_and_clear();
    }

    if !quiet {
        println!(
            "\n{} {} recently modified files found",
            "‚úì".green().bold(),
            results.len().to_string().cyan().bold()
        );
    }

    if let Some(output) = output_file {
        let content = results
            .iter()
            .map(|(p, t)| {
                let mins_ago = (now - t) / 60;
                format!("{} ({} minutes ago)", p, mins_ago)
            })
            .collect::<Vec<_>>()
            .join("\n");
        fs::write(&output, content)
            .with_context(|| format!("Failed to write to output file: {}", output))?;
        if !quiet {
            println!("Results saved to: {}", output.cyan());
        }
    }

    Ok(())
}
